export const binaryTreesData = [
  {
    id: "preorder-recursive",
    title: "Preorder Traversal (Recursive)",
    category: "Tree Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/binary-tree-preorder-traversal/",
    algorithm: [
      "Print(value)",
      "Preorder(node->left)",
      "Preorder(node->right)",
    ],
  },
  {
    id: "inorder-recursive",
    title: "Inorder Traversal (Recursive)",
    category: "Tree Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/binary-tree-inorder-traversal/",
    algorithm: ["Inorder(node->left)", "Print(value)", "Inorder(node->right)"],
  },
  {
    id: "postorder-recursive",
    title: "Postorder Traversal (Recursive)",
    category: "Tree Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/binary-tree-postorder-traversal/",
    algorithm: [
      "Postorder(node->left)",
      "Postorder(node->right)",
      "Print(value)",
    ],
  },
  {
    id: "level-order",
    title: "Level Order Traversal",
    category: "Tree Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/binary-tree-level-order-traversal/",
    algorithm: [
      "Take a Queue and put root node in it",
      "Run loop while queue not empty",
      "Calculate queue size (current level size)",
      "Run a loop from 0 to queue size",
      "  - If left exists, add left",
      "  - If right exists, add right",
      "Store current level nodes in a temp list and add the list to result List",
      "Return result",
    ],
  },
  {
    id: "preorder-iterative",
    title: "Preorder Traversal (Iterative)",
    category: "Tree Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/binary-tree-preorder-traversal/",
    algorithm: [
      "Take stack and store root",
      "Loop until stack empty",
      "  - Pop and store in result list",
      "  - If right exists, store right",
      "  - If left exists, store left",
      "Return result",
    ],
  },
  {
    id: "inorder-iterative",
    title: "Inorder Traversal (Iterative)",
    category: "Tree Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/binary-tree-inorder-traversal/",
    algorithm: [
      "Take a stack to traverse and List to store result",
      "Take a curr ptr and store root",
      "Run a while loop until curr is null or stack is not empty",
      "  - While curr not null:",
      "    - Push curr to stack",
      "    - Move curr to left child",
      "  - Pop the topmost node from stack and store its value in result list",
      "  - Move curr to right child",
      "Return result",
    ],
  },
  {
    id: "postorder-iterative-2stack",
    title: "Postorder Traversal (Iterative - 2 Stacks)",
    category: "Tree Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/binary-tree-postorder-traversal/",
    algorithm: [
      "Take stk1 having root node and stk2 empty",
      "While stk1 is not empty:",
      "  - Pop the node and store its value in stk2",
      "  - If left child exists, store in stk1",
      "  - If right child exists, store in stk1",
      "Now stk2 will contain all values",
      "Run a loop to extract values from it and store in a list",
      "Return the list",
    ],
  },
  {
    id: "postorder-iterative-1stack",
    title: "Postorder Traversal (Iterative - 1 Stack)",
    category: "Tree Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/binary-tree-postorder-traversal/",
    algorithm: [
      "Take list for result, stack for traversal",
      "Set curr as root node",
      "Set lastVisited as null to track previous node",
      "While curr != null or stack is not empty:",
      "  - While curr != null, keep pushing left node into stack",
      "  - Take the topmost node as peek variable",
      "  - If (lastVisited != peek.right && peek.right != null):",
      "    - Then curr = peek.right",
      "  - Else:",
      "    - Add peek node value to result array",
      "    - Do lastVisited = stack.pop",
      "Return result",
    ],
  },
  {
    id: "height-of-tree",
    title: "Height of Binary Tree",
    category: "Tree Properties",
    leetcodeLink: "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
    algorithm: [
      "Height = 1 + max(Height(left subtree), Height(right subtree))",
      "Null node means 0 height",
    ],
  },
  {
    id: "balanced-tree",
    title: "Balanced Binary Tree",
    category: "Tree Properties",
    leetcodeLink: "https://leetcode.com/problems/balanced-binary-tree/",
    note: "A balanced binary tree is a tree where difference of height of left and right subtree is ≤ 1",
    algorithm: [
      "In main function, return (Height(root) != -1)",
      "In Height function:",
      "if (root == null) return 0",
      "Calculate left height of tree and store in variable",
      "Calculate right height of tree and store in variable",
      "If (left height == -1 || right height == -1) return -1",
      "If (|left height – right height| > 1) return -1",
      "Return height: 1 + max(Height(left subtree), Height(right subtree))",
    ],
  },
  {
    id: "diameter",
    title: "Diameter of Binary Tree",
    category: "Tree Properties",
    leetcodeLink: "https://leetcode.com/problems/diameter-of-binary-tree/",
    hint: "Max height of left + right subtree",
    algorithm: [
      "Take a global max variable",
      "Perform height of a tree algo as a function",
      "In height function:",
      "  - If node == null, return 0",
      "  - Calculate left height",
      "  - Calculate right height",
      "Store max of (max, left height + right height) inside the function",
      "Return height: 1 + max(left height, right height)",
      "Return max in main function",
    ],
  },
  {
    id: "max-path-sum",
    title: "Maximum Path Sum",
    category: "Tree Properties",
    leetcodeLink: "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
    hint: "Combination of height and diameter of a binary tree",
    algorithm: [
      "Take a global max variable as Integer.MIN_VALUE",
      "Perform height of a tree algo as a function",
      "In height function:",
      "  - If node == null, return 0",
      "  - Calculate left height",
      "  - Calculate right height",
      "Store max of (max, left height + right height + node.val) inside the function",
      "Return height: node.val + max(left height, right height)",
      "Return max in main function",
    ],
  },
  {
    id: "same-tree",
    title: "Same / Identical Tree",
    category: "Tree Properties",
    leetcodeLink: "https://leetcode.com/problems/same-tree/",
    algorithm: [
      "If both nodes are null, return true",
      "If one node is null and other is not, return false",
      "If both node values are not equal, return false",
      "Now recursively check left and right subtree",
      "Return their AND result",
    ],
  },
  {
    id: "zigzag-traversal",
    title: "Zig-Zag Traversal",
    category: "Advanced Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",
    hint: "Level order traversal with a flag variable",
  },
  {
    id: "boundary-traversal",
    title: "Boundary Traversal (Anticlockwise)",
    category: "Advanced Traversals",
    leetcodeLink: "https://leetcode.com/problems/boundary-of-binary-tree/",
    hint: "Left boundary w/o leaf nodes + Leaf nodes + Right boundary in reverse w/o leaf nodes",
    algorithm: [
      "In main function Take a result list and a stack to store right subtree",
      "If root == null, return list",
      "Add root.val to list",
      "Send root.left to left boundary function",
      "Send root.left to leaf nodes function",
      "Send root.right to right boundary function",
      "Left Boundary:",
      "  - Start from root node",
      "  - Keep going left node",
      "  - If no left available, go to right",
      "  - Keep storing, as soon as you reach leaf, stop there",
      "Leaf Nodes:",
      "If node == null, return",
      "  - Perform inorder traversal on whole tree and store the leaf nodes in the list",
      "Right Boundary:",
      "  - Start from root's right",
      "  - Keep going to right child and if not available, go to left and store them in stack",
      "  - Once reach leaf node, stop there",
      "  - Store all stack elements in the list",
      "Return list",
    ],
  },
  {
    id: "vertical-view",
    title: "Vertical Order Traversal",
    category: "Advanced Traversals",
    leetcodeLink:
      "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/",
    algorithm: [
      "Take a global list of int array",
      "Send root, 0, 0 in a dfs function",
      "In DFS function:",
      "  - If node == null, return",
      "  - List.add(new int[]{col, row, node.val})",
      "  - Call dfs(node.left, row+1, col-1)",
      "  - Call dfs(node.right, row+1, col+1)",
      "Inside main function:",
      "  - Perform sorting: col → row → value",
      "    Like this :  Collections.sort(list, (a, b) -> {",
      "    if (a[0] != b[0]) return a[0] - b[0];",
      "    if (a[1] != b[1]) return a[1] - b[1];",
      "    return a[2] - b[2];",
      "    });",
      "  - Create a result list of list",
      "  - prevCol variable to store Integer.MIN_VALUE",
      "  - Loop through sorted nodes, like : for(int[] arr:list){}",
      "    - If arr[0]!=prevCol",
      "        - result.add(new ArrayList<>())",
      "        - prevCol=arr[0];",
      "    - result.get(result.size()-1).add(arr[2])",
      "Return result",
    ],
  },
  {
    id: "top-view",
    title: "Top View of Binary Tree",
    category: "Advanced Traversals",
    leetcodeLink: "https://leetcode.com/problems/binary-tree-top-view/",
    hint: "Vertical traversal where we add first node of each column in result array/list",
    algorithm: [
      "Take a List of integers for result",
      "If root == null, return result",
      "Take a TreeMap : TreeMap<Integer,Integer> tree= new TreeMap<>()",
      "Take 2 Queues (one for nodes and one for cols)",
      "Add root in valQueue and 0 in colQueue",
      "While valQueue not empty:",
      "  - Remove the node stored in valQueue and col in colQueue",
      "  - Store in temp variable",
      "  - Store in Map if not present yet: map.putIfAbsent(col, node.val)",
      "  - If left child exists: add left child and col-1",
      "  - If right child exists: add right child and col+1",
      "Add all map values to result list : for (int val2 : tree.values()){}",
      "Return result list",
    ],
  },
  {
    id: "bottom-view",
    title: "Bottom View of Binary Tree",
    category: "Advanced Traversals",
    leetcodeLink: "https://leetcode.com/problems/binary-tree-bottom-view/",
    hint: "Same as top view but here we add the last added node to the map (always update)",
    algorithm: [
      "Take a List of integers for result",
      "If root == null, return result",
      "Take a TreeMap : TreeMap<Integer,Integer> tree= new TreeMap<>()",
      "Take 2 Queues (one for nodes and one for cols)",
      "Add root in valQueue and 0 in colQueue",
      "While valQueue not empty:",
      "  - Remove the node stored in valQueue and col in colQueue",
      "  - Store in temp variable",
      "  - Store in Map if not present yet: map.put(col, node.val)",
      "  - If left child exists: add left child and col-1",
      "  - If right child exists: add right child and col+1",
      "Add all map values to result list : for (int val2 : tree.values()){}",
      "Return result list",
    ],
  },
  {
    id: "right-side-view",
    title: "Right Side View",
    category: "Advanced Traversals",
    leetcodeLink: "https://leetcode.com/problems/binary-tree-right-side-view/",
    hint: "Traverse root → right → left (recursive)",
    algorithm: [
      "Take a result list of int to return",
      "Call func rightView and pass (root, result, 0)",
      "In function: rightView(TreeNode root, List<Integer> arr, int currDepth)",
      "  - If root == null, return",
      "  - If currDepth == arr.size() then arr.add(curr.val)",
      "  - Call func recursively(curr.right, arr, currDepth+1)",
      "  - Call func recursively(curr.left, arr, currDepth+1)",
      "Return result in main function",
    ],
  },
  {
    id: "symmetrical-tree",
    title: "Symmetrical Binary Tree",
    category: "Advanced Traversals",
    leetcodeLink: "https://leetcode.com/problems/symmetric-tree/",
    hint: "Tree should be a mirror image from root",
    algorithm: [
      "Call a function and pass root.left, root.right",
      "In function:",
      "  - Recursively check for both tree's values",
      "  - Keep calling left and right child",
      "  - Return their AND result",
    ],
  },
  {
    id: "root-to-node-path",
    title: "Root to Node Path",
    category: "Path Finding",
    leetcodeLink: "https://leetcode.com/problems/path-sum-ii/",
    algorithm: [
      "Take a global list of list of integers:result to store all paths",
      "In main Function:",
      "Call getPath(root, targetSum, new ArrayList<>()) -> inner list to hold single path",
      "return result",
      "Inside function: void getPath(TreeNode root, int targetSum, List<Integer> path)",
      "  - If root == null, return false",
      "  - Add root.val to path",
      "  - If (root.left == null && root.right == null && targetSum == root.val):",
      "       - result.add(new ArrayList<>(path));",
      "    Else:",
      "       - getPath(root.left, targetSum - root.val, path)",
      "       - getPath(root.right, targetSum - root.val, path)",
      "  - Remove last element from path list (backtracking)",
    ],
  },
  {
    id: "lowest-common-ancestor",
    title: "Lowest Common Ancestor",
    category: "Path Finding",
    leetcodeLink:
      "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
    algorithm: [
      "Base case: if(root == null || root == p || root == q) return root",
      "Create 2 variables and call function",
      "TreeNode left = lowestCommonAncestor(root.left, p, q)",
      "TreeNode right = lowestCommonAncestor(root.right, p, q)",
      "Result:",
      "if(left == null) return right",
      "else if(right == null) return left",
      "else return root",
    ],
  },
  {
    id: "max-width-tree",
    title: "Maximum Width of Binary Tree",
    category: "Special Problems",
    leetcodeLink: "https://leetcode.com/problems/maximum-width-of-binary-tree/",
    note: "TODO: Algorithm to be added",
    algorithm: [],
  },
  {
    id: "children-sum-property",
    title: "Children Sum Property",
    category: "Special Problems",
    leetcodeLink: "https://leetcode.com/problems/children-sum-parent/",
    algorithm: [
      "If root == null, return",
      "Take child variable = 0",
      "If left child not null, then child += root.left.val",
      "If right child not null, then child += root.right.val",
      "If child >= root.data, then root.data = child",
      "Else:",
      "  - If (root.left != null), root.left.data = root.data",
      "  - Else if (root.right != null), root.right.data = root.data",
      "Recursively call root.left",
      "Recursively call root.right",
      "Take total variable = 0",
      "If left child not null, then total += root.left.data",
      "If right child not null, then total += root.right.data",
      "If left child or right child not null, then root.data = total",
    ],
  },
  {
    id: "nodes-at-distance-k",
    title: "Print all the Nodes at a Distance of K",
    category: "Special Problems",
    leetcodeLink:
      "https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/",
    hint: "Mark parent pointers and perform a BFS traversal",
    note: "TODO: Detailed algorithm to be added",
    algorithm: [],
  },
  {
    id: "burn-tree",
    title: "Minimum Time Taken to Burn the Binary Tree from a Node",
    category: "Special Problems",
    leetcodeLink:
      "https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/",
    hint: "Mark parent pointers and perform a BFS traversal",
    note: "TODO: Detailed algorithm to be added",
    algorithm: [],
  },
  {
    id: "count-nodes-complete-tree",
    title: "Count Nodes in Complete Binary Tree",
    category: "Complete Binary Tree",
    leetcodeLink: "https://leetcode.com/problems/count-complete-tree-nodes/",
    algorithm: [
      "If root == null, return 0",
      "Check left and right subtree height",
      "If equal, return: 2^(height+1) - 1",
      "Else return: 1 + countNode(root.left) + countNode(root.right)",
      "Calculate left and right height using separate functions",
    ],
  },
  {
    id: "construct-from-preorder-inorder",
    title: "Construct Tree from Preorder and Inorder",
    category: "Tree Construction",
    leetcodeLink:
      "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
    algorithm: [
      "Create a HashMap of <int, int> and store inorder values and indexes",
      "Create TreeNode root",
      "Call: BuildTree(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1)",
      "Inside function:",
      "  - If (preStart > preEnd || inStart > inEnd), return null",
      "  - Create root using preorder[preStart]",
      "  - inRoot = index from map",
      "  - numsLeft = inRoot – inStart",
      "  - Root.left = buildTree(preorder, preStart+1, preStart+numsLeft, inorder, inStart, inRoot-1)",
      "  - Root.right = buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd)",
      "Return root",
    ],
  },
  {
    id: "construct-from-postorder-inorder",
    title: "Construct Tree from Postorder and Inorder",
    category: "Tree Construction",
    leetcodeLink:
      "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",
    algorithm: [
      "If invalid input, return null",
      "Create HashMap of inorder indexes",
      "Call: BuildTree(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1)",
      "Inside function:",
      "  - If invalid range, return null",
      "  - Create root using postorder[postEnd]",
      "  - inRoot from map",
      "  - numsLeft = inRoot – inStart",
      "  - Root.left = buildTree(inorder, inStart, inRoot-1, postorder, postStart, postStart+numsLeft-1)",
      "  - Root.right = buildTree(inorder, inRoot+1, inEnd, postorder, postStart+numsLeft, postEnd-1)",
      "Return root",
    ],
  },
  {
    id: "serialize-deserialize",
    title: "Serialize and Deserialize Binary Tree",
    category: "Serialization",
    leetcodeLink:
      "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
    hint: 'Perform a level order traversal and make a string for serialization. Use node values and "n" for null children.',
    algorithm: [
      "Serialization:",
      '  - If root == null, return ""',
      "  - Take a queue q and StringBuilder sb",
      "  - Add root to queue",
      "  - While queue not empty:",
      "    - Remove the node and store it in temp var",
      '    - If node == null, append "n " to sb and continue',
      '    - sb.append(node.val + " ")',
      "    - Add left child to queue",
      "    - Add right child to queue",
      "  - Return this string",
      "Deserialization:",
      '  - If (data == ""), return null',
      "  - Take a queue of TreeNode",
      '  - Create String array values by data.split(" ")',
      "  - Create root = new TreeNode(Integer.parseInt(values[0]))",
      "  - Add root to queue",
      "  - Run a loop from i = 1 to values.length:",
      "    - Take a variable TreeNode parent = q.poll()",
      '    - If (!values[i].equals("n")):',
      "      - TreeNode left = new TreeNode(Integer.parseInt(values[i]))",
      "      - parent.left = left",
      "      - q.add(left)",
      '    - If (++i < values.length && !values[i].equals("n")):',
      "      - TreeNode right = new TreeNode(Integer.parseInt(values[i]))",
      "      - parent.right = right",
      "      - q.add(right)",
      "  - Return root",
    ],
  },
  {
    id: "flatten-to-linked-list",
    title: "Flatten Binary Tree to Linked List",
    category: "Serialization",
    leetcodeLink:
      "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/",
    algorithm: [
      "Take a variable curr and store root",
      "Run a loop while (curr != null):",
      "  - If curr.left != null:",
      "    - Take a prev TreeNode variable and store curr.left",
      "    - Go to the rightmost child of prev",
      "    - prev.right = curr.right",
      "    - curr.right = curr.left",
      "    - curr.left = null",
      "  - curr = curr.right",
      "Return",
    ],
  },
];

export const categories = [
  "Tree Traversals",
  "Tree Properties",
  "Advanced Traversals",
  "Path Finding",
  "Special Problems",
  "Complete Binary Tree",
  "Tree Construction",
  "Serialization",
];

// Data structure organization
export const dataStructures = {
  "Binary Trees": {
    categories: categories,
    questions: binaryTreesData,
  },
  // Placeholder for future data structures
  Arrays: {
    categories: ["Sorting", "Searching", "Two Pointers"],
    questions: [],
  },
  "Linked Lists": {
    categories: ["Traversal", "Manipulation", "Cycle Detection"],
    questions: [],
  },
  Graphs: {
    categories: ["BFS", "DFS", "Shortest Path"],
    questions: [],
  },
  "Dynamic Programming": {
    categories: ["1D DP", "2D DP", "Subsequence"],
    questions: [],
  },
};

export const dataStructureNames = Object.keys(dataStructures);
